##################################################
# !!!!DO NOT EDIT THIS FILE!!!!
# (unless you know what you are doing)
##################################################
#place to store the dependency files in
DEPDIR = ./.dep/
#place to store binary files in
BINDIR = ./bin/
#place to store object files in
OBJDIR = ./bin/obj/
#place to store vpath information in
VPDIR = ./.vpath/

#clear builtin rules to boost performance (see make -p -f/dev/null and make -d for details)
.SUFFIXES:
MAKEFLAGS += --no-builtin-rules

#TODO: has to be redone to not generate not found errors before configure has been run
#setting finding all paths that contain c, cpp and h, hpp files
vpath %.cpp = $(shell if [ -e $(VPDIR) ]; then cat $(VPDIR)'vpath_info_cpp.txt'; fi )
vpath %.c = $(shell if [ -e $(VPDIR) ]; then cat $(VPDIR)'vpath_info_c.txt'; fi )
vpath %.hpp = $(shell if [ -e $(VPDIR) ]; then cat $(VPDIR)'vpath_info_hpp.txt'; fi )
vpath %.h = $(shell if [ -e $(VPDIR) ]; then cat $(VPDIR)'vpath_info_h.txt'; fi )

##################################################
# generate folders as needed
##################################################
$(BINDIR) :
	@mkdir -p $(BINDIR)

#object file needs to be created after the binary directory has been created
$(OBJDIR) : | $(BINDIR)
	@mkdir -p $(OBJDIR)

#dependency directory without prerequisite
$(DEPDIR) :
	@mkdir -p $(DEPDIR)

VPDIR :
	@echo [STATUS] generating vpath information
	@$(SHELL) -ec 'if [ ! -e $(VPDIR) ]; then mkdir $(VPDIR); fi'
	@$(SHELL) -ec "find -L $(DEPENDENCYDIRS) -name '*.cpp' -printf \"%h\n\" | sort -u | tr '\n' ':' | sed 's/.$$//' > $(VPDIR)vpath_info_cpp.txt"
	@$(SHELL) -ec "find -L $(DEPENDENCYDIRS) -name '*.c' -printf \"%h\n\" | sort -u | tr '\n' ':' | sed 's/.$$//' > $(VPDIR)vpath_info_c.txt"
	@$(SHELL) -ec "find -L $(DEPENDENCYDIRS) -name '*.hpp' -printf \"%h\n\" | sort -u | tr '\n' ':' | sed 's/.$$//' > $(VPDIR)vpath_info_hpp.txt"
	@$(SHELL) -ec "find -L $(DEPENDENCYDIRS) -name '*.h' -printf \"%h\n\" | sort -u | tr '\n' ':' | sed 's/.$$//' > $(VPDIR)vpath_info_h.txt"

#################################################
# Cleanup
#################################################
$(CLEAN_TARGETS) :
	@rm -f $(sort $(filter %.o, $(shell cat $(DEPDIR)$(patsubst clean.%,%,$@)$(SUFFIX).d 2>/dev/null)))
	@rm -f $(BINDIR)$(patsubst clean.%,%,$@)$(SUFFIX)
	@rm -f $(DEPDIR)$(patsubst clean.%,%,$@)$(SUFFIX).d

configure: VPDIR

clean:
	@rm -rf $(OBJDIR)
	@rm -rf $(BINDIR)
	@rm -rf $(DEPDIR)
	@rm -f $(LOGFILES)

##################################################
# Generation of dependency file information
##################################################

#TODO make shellscript as a callable function
$(DEPDIR)%.par.d : %.cpp | $(DEPDIR)
	@echo [STATUS] generating dependency file for parallel: $(@F)
	@$(CXX) $(CXXPFLAGS) -MM -MD $< -MF $(DEPDIR)$(@F)
	@sed -i 's|\(.*\)\.o:|$(OBJDIR)\1.par.o $(DEPDIR)\1.par.d:|' $(DEPDIR)$(@F)
#rename existing .h files to .o files if the cpp exists (dependency file for .d and .o)
	@for i in `cat $(DEPDIR)$(@F)`; do \
		if [ $$i != "\\" ]; then \
			FILENAME=$${i%\.*}; \
			if [ -f $${FILENAME}.cpp ]; then \
				BASE=`basename $$i`; \
				if [ $${BASE%.*} != $* ]; then \
					echo -n $(OBJDIR)$${BASE%.*}.par.o\ >> $(DEPDIR)$(*F).n; \
				else \
						echo "$${FILENAME}.cpp \\" >> $(DEPDIR)$(*F).n; \
				fi\
			else \
				echo -n $$i\  >> $(DEPDIR)$(*F).n; \
			fi \
		else \
			echo $$i  >> $(DEPDIR)$(*F).n; \
		fi \
	done; \
	echo >> $(DEPDIR)$(F).n;
#finally move the temporary file to the dependency file
	@$(SHELL) -ec 'mv $(DEPDIR)$(*F).n $(DEPDIR)$(@F)'

$(DEPDIR)%.par.dbg.d : %.cpp | $(DEPDIR)
	@echo [STATUS] generating dependency file for parallel debug: $(@F)
	@$(CXX) $(CXXPFLAGSDBG) -MM -MD $< -MF $(DEPDIR)$(@F)
	@sed -i 's|\(.*\)\.o:|$(OBJDIR)\1.par.dbg.o $(DEPDIR)\1.par.dbg.d:|' $(DEPDIR)$(@F)
#rename existing .h files to .o files if the cpp exists (dependency file for .d and .o)
	@for i in `cat $(DEPDIR)$(@F)`; do \
		if [ $$i != "\\" ]; then \
			FILENAME=$${i%\.*}; \
			if [ -f $${FILENAME}.cpp ]; then \
				BASE=`basename $$i`; \
				if [ $${BASE%.*} != $* ]; then \
					echo -n $(OBJDIR)$${BASE%.*}.par.dbg.o\ >> $(DEPDIR)$(*F).n; \
				else \
						echo "$${FILENAME}.cpp \\" >> $(DEPDIR)$(*F).n; \
				fi\
			else \
				echo -n $$i\  >> $(DEPDIR)$(*F).n; \
			fi \
		else \
			echo $$i  >> $(DEPDIR)$(*F).n; \
		fi \
	done; \
	echo >> $(DEPDIR)$(F).n;
#finally move the temporary file to the dependency file
	@$(SHELL) -ec 'mv $(DEPDIR)$(*F).n $(DEPDIR)$(@F)'

$(DEPDIR)%.dbg.d : %.cpp | $(DEPDIR)
	@echo [STATUS] generating dependency file for debug: $(@F)
	@$(CXX) $(CXXFLAGSDBG) -MM -MD $< -MF $(DEPDIR)$(@F)
	@sed -i 's|\(.*\)\.o:|$(OBJDIR)\1.dbg.o $(DEPDIR)\1.dbg.d:|' $(DEPDIR)$(@F)
#rename existing .h files to .o files if the cpp exists (dependency file for .d and .o)
	@for i in `cat $(DEPDIR)$(@F)`; do \
		if [ $$i != "\\" ]; then \
			FILENAME=$${i%\.*}; \
			if [ -f $${FILENAME}.cpp ]; then \
				BASE=`basename $$i`; \
				if [ $${BASE%.*} != $* ]; then \
					echo -n $(OBJDIR)$${BASE%.*}.dbg.o\ >> $(DEPDIR)$(*F).n; \
				else \
						echo "$${FILENAME}.cpp \\" >> $(DEPDIR)$(*F).n; \
				fi\
			else \
				echo -n $$i\  >> $(DEPDIR)$(*F).n; \
			fi \
		else \
			echo $$i  >> $(DEPDIR)$(*F).n; \
		fi \
	done; \
	echo >> $(DEPDIR)$(F).n;
#finally move the temporary file to the dependency file
	@$(SHELL) -ec 'mv $(DEPDIR)$(*F).n $(DEPDIR)$(@F)'

$(DEPDIR)%.d : %.cpp | $(DEPDIR)
	@echo [STATUS] generating dependency file: $(@F)
	@$(CXX) $(CXXFLAGS) -MM -MD $< -MF $(DEPDIR)$(@F)
	@sed -i 's|\(.*\)\.o:|$(OBJDIR)\1.o $(DEPDIR)\1.d:|' $(DEPDIR)$(@F)
#rename existing .h files to .o files if the cpp exists (dependency file for .d and .o)
	@for i in `cat $(DEPDIR)$(@F)`; do \
		if [ $$i != "\\" ]; then \
			FILENAME=$${i%\.*}; \
			if [ -f $${FILENAME}.cpp ]; then \
				BASE=`basename $$i`; \
				if [ $${BASE%.*} != $* ]; then \
					echo -n $(OBJDIR)$${BASE%.*}.o\ >> $(DEPDIR)$(*F).n; \
				else \
						echo "$${FILENAME}.cpp \\" >> $(DEPDIR)$(*F).n; \
				fi\
			else \
				echo -n $$i\  >> $(DEPDIR)$(*F).n; \
			fi \
		else \
			echo $$i  >> $(DEPDIR)$(*F).n; \
		fi \
	done; \
	echo >> $(DEPDIR)$(F).n;
#finally move the temporary file to the dependency file
	@$(SHELL) -ec 'mv $(DEPDIR)$(*F).n $(DEPDIR)$(@F)'

##################################################
# Building the object files
##################################################
$(OBJDIR)%.par.o : %.cpp %.h | $(OBJDIR)
	@echo [STATUS] Building object file $(@F)
	@echo [COMMAND] $(CXX) $(CXXPFLAGS) -c ./$< -o ./$@
	@$(CXX) $(CXXPFLAGS) -c ./$< -o ./$@

$(OBJDIR)%.par.dbg.o : %.cpp %.h | $(OBJDIR)
	@echo [STATUS] Building object file $(@F)
	@echo [COMMAND] $(CXX) $(CXXPFLAGSDBG) -c ./$< -o ./$@
	@$(CXX) $(CXXPFLAGSDBG) -c ./$< -o ./$@

$(OBJDIR)%.dbg.o : %.cpp %.h | $(OBJDIR)
	@echo [STATUS] Building object file $(@F)
	@echo [COMMAND] $(CXX) $(CXXFLAGSDBG) -c ./$< -o ./$@
	@$(CXX) $(CXXFLAGSDBG) -c ./$< -o ./$@

$(OBJDIR)%.o : %.cpp %.h | $(OBJDIR)
	@echo [STATUS] Building object file $(@F)
	@echo [COMMAND] $(CXX) $(CXXFLAGS) -c ./$< -o ./$@
	@$(CXX) $(CXXFLAGS) -c ./$< -o ./$@

$(OBJDIR)%.par.o : %.cpp | $(OBJDIR)
	@echo [STATUS] Building object file $(@F)
	@echo [COMMAND] $(CXX) $(CXXPFLAGS) -c ./$< -o ./$@
	@$(CXX) $(CXXPFLAGS) -c ./$< -o ./$@

$(OBJDIR)%.par.dbg.o : %.cpp | $(OBJDIR)
	@echo [STATUS] Building object file $(@F)
	@echo [COMMAND] $(CXX) $(CXXPFLAGSDBG) -c ./$< -o ./$@
	@$(CXX) $(CXXPFLAGSDBG) -c ./$< -o ./$@

$(OBJDIR)%.dbg.o : %.cpp | $(OBJDIR)
	@echo [STATUS] Building object file $(@F)
	@echo [COMMAND] $(CXX) $(CXXFLAGSDBG) -c ./$< -o ./$@
	@$(CXX) $(CXXFLAGSDBG) -c ./$< -o ./$@

$(OBJDIR)%.o : %.cpp | $(OBJDIR)
	@echo [STATUS] Building object file $(@F)
	@echo [COMMAND] $(CXX) $(CXXFLAGS) -c ./$< -o ./$@
	@$(CXX) $(CXXFLAGS) -c ./$< -o ./$@

##################################################
# Rules to actually make the targets
##################################################
$(BINDIR)%.par : $(DEPDIR)%.par.d $(OBJDIR)%.par.o | $(DEPDIR) $(OBJDIR)
	@echo [STATUS] building executeable: $(@F)
	@echo [COMMAND] $(CXX) $(CXXPFLAGS) $(CXXPLIBS) $(sort $(filter %.o, $(shell cat $<))) $(CXXPLIBS) -o $@
	@$(CXX) $(CXXPFLAGS) $(CXXPLIBS) $(sort $(filter %.o, $(shell cat $<))) $(CXXPLIBS) -o $@

$(BINDIR)%.par.dbg : $(DEPDIR)%.par.dbg.d $(OBJDIR)%.par.dbg.o | $(DEPDIR) $(OBJDIR)
	@echo [STATUS] building executeable: $(@F)
	@echo [COMMAND] $(CXX) $(CXXPFLAGSDBG) $(sort $(filter %.o, $(shell cat $<))) $(CXXPLIBS) -o $@
	@$(CXX) $(CXXPFLAGSDBG) $(sort $(filter %.o, $(shell cat $<))) $(CXXPLIBS) -o $@

(BINDIR)%.dbg : $(DEPDIR)%.dbg.d $(OBJDIR)%.dbg.o | $(DEPDIR) $(OBJDIR)
	@echo [STATUS] building executeable: $(@F)
	@echo [COMMAND] $(CXX) $(CXXFLAGSDBG) $(sort $(filter %.o, $(shell cat $<))) $(CXXLIBS) -o $@
	@$(CXX) $(CXXFLAGSDBG) $(sort $(filter %.o, $(shell cat $<))) $(CXXLIBS) -o $@

$(BINDIR)% : $(DEPDIR)%.d $(OBJDIR)%.o | $(DEPDIR) $(OBJDIR)
	@echo [STATUS] building executeable: $(@F)
	@echo [COMMAND] $(CXX) $(CXXFLAGS) $(sort $(filter %.o, $(shell cat $<))) $(CXXLIBS) -o $@
	@$(CXX) $(CXXFLAGS) $(sort $(filter %.o, $(shell cat $<))) $(CXXLIBS) -o $@

################################################
# Wrapper to map targets to bindir
################################################
% : $(BINDIR)%$(SUFFIX) ;

##############################
#DEPENDENCY INCLUSION
##############################
dependency_search = $(if $1,$(sort $(patsubst $(OBJDIR)%.o,$(DEPDIR)%.d,$(filter %.o, $(shell grep -sh "" $(1) )))),)

#make dependency files not temporary files
.SECONDARY: $(addprefix $(BINDIR),$(TARGETS)) $(addprefix $(BINDIR),$(addsuffix .par,$(PARALLEL))) $(addsuffix .dbg,$(addprefix $(BINDIR),$(TARGETS))) $(addsuffix .dbg,$(addprefix $(BINDIR),$(addsuffix .par,$(PARALLEL))))
#.SECONDARY: $(DEP_FILES)

#generate dependency files
DEP_FILES = $(addsuffix .d,$(addprefix $(DEPDIR),$(BUILD_TARGETS)))

#include the dependeny files of current targets, list is generated above
-include $(DEP_FILES)
-include $(call dependency_search,$(DEP_FILES))
